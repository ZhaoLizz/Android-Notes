# 多线程编程

- 更新UI会造成不稳定，所以UI必须在主线程更新

  ## 一、基本用法

  1. Runnable接口 ```java class MyThread implements Runnable{ @Override public void run(){ //... } }

MyThread myThread = new MyThread(); //Thread()构造方法接受一个Runnable参数 new Thread(myThread).start();

````
2\. 匿名类方式

```java
new Thread(new Runnable(){
  @Override
  public void run(){
    //...
  }
}).start();
````

## 二、异步处理消息

**组成部分：**

1. Message：是在线程之间传递的消息，通过给message.what message.obj赋值使此对象携带数据
2. Handler：用于发送和处理消息 在子线程中handler.sendMessage(message);然后主线程中接收并处理消息handler.handleMessage();
3. MessageQueue：消息队列，用于存放所有通过Handler发送的消息。每个线程只能有一个MessageQueue对象
4. Looper：管理每个线程中的MessageQueue。调用Looper.loop()后，进入无限循环中，每当发现MessagQueue中存在消息时就把他取出并传递到handleMessage()方法中

**使用流程**

1. 在主线程中创建Handler对象，并重写handleMessage()方法
2. 当子线程需要UI操作时，创建一个Message对象，并通过handler.sendMessage发送出去
3. 在主线程的handler.handMessage()中处理消息

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{
    public static final int UPDATA_TEXT = 1;
    private TextView text;

    //创建handler对象
    private Handler handler = new Handler(){

        //重写父类的handleMessage
        //调用Handler.sendMessage()后自动调用此方法处理结果
        public void handleMessage(Message msg){
            switch (msg.what){
                case UPDATA_TEXT:
                    text.setText("Nice to meet u");
                    break;
                default:
                    break;
            }
        }
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        text = (TextView)findViewById(R.id.text);
        Button changeText =(Button)findViewById(R.id.change_text);
        changeText.setOnClickListener(this);
    }

    @Override
    public void onClick(View v) {
        switch(v.getId()){
            case R.id.change_text:

                new Thread(new Runnable() {
                    @Override
                    public void run() {
                        Message message = new Message();
                        message.what = UPDATA_TEXT;
                        //Handler.发送message，然后Handler收到message后自动调用handleMessage()
                        //handleMessage在主线程进行
                        handler.sendMessage(message);
                    }
                }).start();

                break;
            default:
                break;
        }
    }
}
```

## 三、使用封装好的异步消息处理机制：AsyncTask

- AsyncTask是一个抽象类，有三个泛型参数。 第一个Params：传入给后台任务使用。第二个Progress，后台任务执行时如果想在界面显示进度，这里表示进度的单位。第三个Result：任务执行完毕后的返回值类型

  ```java
  class DownloadTask extends AsyncTask<Void,Integer,Boolean>
  ```

- 需要重写的方法：

- onPreExecute():进行一些界面上的初始化操作

- doInBackground(Params...)：这个方法中所有的代码都在字线程中执行，在这里去处理所有的耗时任务。在此方法内执行publishProgress(Progress...)后台调用，向主线程发送信息，更新UI，比如反馈当前任务的执行进度

- onProgressUpdata(Progress...)：在这里处理结果，参数就是在后台任务中传递进来的，可以对UI进行操作。publishProgress被调用后此方法被调用。
- onPostExecute(Result)：后台任务执行完毕并通过return返回时调用此方法，用来处理后台返回的数据

**使用步骤：**

1. onPreExecute初始化界面
2. doInBackground执行具体的耗时任务，publishProgress向主线程发送数据（主要用于UI操作）
3. onProgressUpdata进行UI操作
4. onPostExecute执行任务的收尾工作

  ```java
  //模拟下载任务
  //启动方法： new DownloadTask().execute();
  class DownloadTask extends AsyncTask<Void,Integer,Boolean>{

     @Override
     //界面初始化操作
     protected void onPreExecute() {
         //显示进度对话框
         progressDialog.show();
     }

     @Override
     //在子线程处理耗时任务，并向主线程发送信息
     protected Boolean doInBackground(Void... params) {
         try{
             while(true){
                 int downloadPercent = doDownload();
                 //发送信息
                 publishProgress(downloadPercent);
                 if(downloadPercent >= 100){
                     break;
                 }
             }
         }catch (Exception e){
             return false;
         }
         return true;
     }

     @Override
     //接收后台传来的信息
     protected void onProgressUpdate(Integer... values) {
         progressDialog.setMessage("Downloaded"+ values[0] + "%");
     }

     @Override
     //后台任务执行完毕执行return时调用此方法。
     protected void onPostExecute(Boolean result) {
         //关闭进度对话框
         progressDialog.dismiss();
         if(result){
             Toast.makeText(MainActivity.this, "Download succeeded", Toast.LENGTH_SHORT).show();
         }else{
             Toast.makeText(MainActivity.this, "Download failed", Toast.LENGTH_SHORT).show();
         }
     }
  }
  ```
