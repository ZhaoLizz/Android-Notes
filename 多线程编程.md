# 多线程编程

- 更新UI会造成不稳定，所以UI必须在主线程更新

## 一、基本用法

1. Runnable接口

```java
class MyThread implements Runnable{
  @Override
  public void run(){
    //...
  }
}

MyThread myThread = new MyThread();
//Thread()构造方法接受一个Runnable参数
new Thread(myThread).start();
```

1. 匿名类方式

```java
new Thread(new Runnable(){
  @Override
  public void run(){
    //...
  }
}).start();
```

## 二、异步处理消息



**组成部分：**

1. Message：是在线程之间传递的消息,
    * `message.what`拥护定义的int型消息代码,用来描述消息
    * `message.obj`用户指定随消息发送的对象
    * `message.target`处理消息的Handler
2. Handler：用于**发送和处理消息**.
    * 在子线程中`handler.sendMessage(message);`
    * 然后主线程中接收并处理消息`handler.handleMessage();`
    * 一个Message只与一个目标Handler相关联.
    * Hanlder默认与创建它的当前线程的Looper相关联
    * 创建信息时,最好调用`Handler.obtainMessage(what,obj)`传入其他消息字段后,该方法自动为创建的Message设置目标Handler.一旦取得Message,可以调用`sendToTarget`方法将其发送给它的Handler,然后Handler将这个Message放置在Looper消息队列的尾部.此方法创建的Message从回收池中获取,避免创建新实例,更高效
3. MessageQueue：消息队列，用于存放所有通过Handler发送的消息。每个线程只能有一个MessageQueue对象
4. Looper：管理每个线程中的MessageQueue。调用Looper.loop()后，进入无限循环中，每当发现MessagQueue中存在消息时就把他取出并传递到handleMessage()方法中

**使用流程**

1. 在主线程中创建Handler对象，并重写handleMessage()方法
2. 当子线程需要UI操作时，创建一个Message对象，并通过handler.sendMessage发送出去
3. 在主线程的handler.handMessage()中处理消息

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{
    public static final int UPDATA_TEXT = 1;
    private TextView text;

    //创建handler对象
    private Handler handler = new Handler(){

        //重写父类的handleMessage
        //调用Handler.sendMessage()后自动调用此方法处理结果
        public void handleMessage(Message msg){
            switch (msg.what){
                case UPDATA_TEXT:
                    text.setText("Nice to meet u");
                    break;
                default:
                    break;
            }
        }
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        text = (TextView)findViewById(R.id.text);
        Button changeText =(Button)findViewById(R.id.change_text);
        changeText.setOnClickListener(this);
    }

    @Override
    public void onClick(View v) {
        switch(v.getId()){
            case R.id.change_text:

                new Thread(new Runnable() {
                    @Override
                    public void run() {
                        Message message = new Message();
                        message.what = UPDATA_TEXT;
                        //Handler.发送message，然后Handler收到message后自动调用handleMessage()
                        //handleMessage在主线程进行
                        handler.sendMessage(message);
                    }
                }).start();

                break;
            default:
                break;
        }
    }
}
```

## 三、使用封装好的异步消息处理机制：AsyncTask

- AsyncTask是一个抽象类，有三个泛型参数。 **第一个**Params：传入给后台任务(doInBackground)使用。在`AsyncTask.execute(Params...)`传入.**第二个**Progress，后台任务执行时如果想在界面显示进度，这里表示进度的单位。**第三个**Result：任务执行完毕后的返回值类型
- 可以通过获取AsyncTask实例控制后台任务的终止`AsyncTask.cancel(boolean)`,一般在`onStop或onDestory`调用,false温和结束,true立即结束
- AsyncTask不适用于重复且长时间运行的任务,比如加载图片

```java
  class DownloadTask extends AsyncTask<Void,Integer,Boolean>
```

- 需要重写的方法：

- onPreExecute():进行一些界面上的初始化操作

- doInBackground(Params...)：这个方法中所有的代码都在字线程中执行，在这里去处理所有的耗时任务。在此方法内执行publishProgress(Progress...)调用onProgressUpdata，在主线程执行，更新UI，比如反馈当前任务的执行进度

- onProgressUpdata(Progress...)：在这里处理结果，参数就是在后台任务中传递进来的，可以对UI进行操作。publishProgress被调用后此方法被调用。

- onPostExecute(Result)：后台任务(doInBackground)执行完毕并通过return返回时调用此方法，用来处理后台返回的数据

**使用步骤：**

1. onPreExecute初始化界面
2. doInBackground执行具体的耗时任务，publishProgress向主线程发送数据（主要用于UI操作）,返回值传递给onPostExecute
3. onProgressUpdata进行UI操作
4. onPostExecute执行任务的收尾工作(主线程)

  ```java
  //模拟下载任务
  //启动方法： new DownloadTask().execute();
  class DownloadTask extends AsyncTask<Void,Integer,Boolean>{

    @Override
    //界面初始化操作
    protected void onPreExecute() {
        //显示进度对话框
        progressDialog.show();
    }

    @Override
    //在子线程处理耗时任务，并向主线程发送信息
    protected Boolean doInBackground(Void... params) {
        try{
            while(true){
                int downloadPercent = doDownload();
                //发送信息
                publishProgress(downloadPercent);
                if(downloadPercent >= 100){
                    break;
                }
            }
        }catch (Exception e){
            return false;
        }
        return true;
    }

    @Override
    //接收后台传来的信息
    protected void onProgressUpdate(Integer... values) {
        progressDialog.setMessage("Downloaded"+ values[0] + "%");
    }

    @Override
    //后台任务执行完毕执行return时调用此方法。
    protected void onPostExecute(Boolean result) {
        //关闭进度对话框
        progressDialog.dismiss();
        if(result){
            Toast.makeText(MainActivity.this, "Download succeeded", Toast.LENGTH_SHORT).show();
        }else{
            Toast.makeText(MainActivity.this, "Download failed", Toast.LENGTH_SHORT).show();
        }
    }
  }
  ```


  ## Looper Handler 和 HandlerThread

  * 在调用HandlerThread实例的fragment中的`onDestory()`方法呢要调用HandlerThread的`quit()`方法结束线程,否则会成为僵尸线程一直运行下去
